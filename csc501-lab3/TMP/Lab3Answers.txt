Additional Tasks

1. The priority inversion problem could cause that a higher-priority process needs to wait for the completion of a lower-priority process.
    1. Priority inheritance is one approach to address this issue. Please give another approach and briefly describe its idea.
    2. Design a test case to show that your approach can address the priority inversion problem.
       You should compare the results that derived from the original XINU implementation (use semaphore)
       and that derived from your implementation (use readers/writer locks). Put your results in Lab3Answers.txt and your test case program
       (name it task1.c) in both ./sys and ./TMP

1. After some time period S increase the priority of random threads that are ready and holding locks could be allowed to exit the critical section.

2.  In the previous method, C would have to wait for A and B to release the lock, given the priorities of 25, 20, and 30 respectively.
    When comparing the results with semaphore without using priority inheritance, we see that C would appropriate the lock from A.

lock with priority inheritance
 W1A : to acquire lock
 W1A : acquired lock
 W1B : to acquire lock
 W1A : to release lock
 W1B : acquired lock
 W1B : to release lock
 W1C start to write
 W1C write done.
semaphore without priority inheritance
 W2A : to wait
 W2A : wait
 W2B : to wait
 W2C start to write
 W2C write done.
 W2A : to signal
 W2B : wait
 W2B : to signal


2. Synchronization is a quite complex issue in operating systems. To show your understanding about process synchronization, you are asked to point out a
   reader/writer synchronization issue in this pesudo-code: task2_sync_issue.c. Multiple reader threads can execute this code concurrently by calling
   do_update. All the variables starting with global_ are global variables. You are asked to describe the potential issue caused by the incorrect
   synchronization and point out at least one possible thread interleaving that would trigger the problem. Put your answer in Lab3Answers.txt
   mentioned above.

   a. do_update  -- Since, a reader lock, it would allow other threads to execute at the same time.
   b. try_update -- The global_semaphore which is a counting semaphore initialized to 10 would not be able to protect the CS.
   c. buffer_add -- is a writer process.
